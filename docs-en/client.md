# Creating strategy

In the package for your programming language you can find `MyStrategy.<ext>`/`my_strategy.<ext>` file.
This file contains `MyStrategy` class, describing logic of your strategy.
Other files contain logic of connecting to the server, game objects description and their de/serialization.
Most of these files are autogenerated, and it is not advisable to change them.

In the beginning of the game server sends constants, and an instance of `MyStrategy` is created (constructor is called).
Then, each tick `get_order` method is called, with current dynamic game state as argument,
and you should return orders for your player, which you wish to execute that tick.

When launching the client, you may pass host and port for connecting in command line arguments,
e. g. `python main.py localhost 31001`.
If no arguments were passed, client will attempt connection to `localhost:31001`.

## Debug interface

Method `get_order` also accepts `debug_interface` as an argument - a special object,
using which you can send debug commands and receive debug state of the app directly from the code of your strategy.
Notice, this object is unavailable when testing on the server, as well as if `--batch-mode` was used.
This is only for local debugging.
Data sent through debug interface from `get_order` method is saved for the tick for which orders were requested.
This way you can see debug data for previous ticks when rewinding.

There is another method for debugging - `debug_update`
This one is called continuously during app's work (but not in batch mode), if client is waiting for the next tick.
Data sent through debug interface from `debug_update` are saved globally,
meaning they will be displayed always, not affected by rewinding.

## Objects description

You can see description of game objects both in client code and in documentation.
Some fields may be absent (denoted as `Option<type>`).
The way this is implemented depends on the language used.
If possible, a dedicated optional (nullable) type would be used,
otherwise other methods may be used (like a nullable pointer type).

Some objects may take one of several forms. The way it is implemented depends on the language.
If possible, a dedicated sum (algebraic) data type is used,
otherwise other methods may be used (like variants being classes inherited from abstract base class).
